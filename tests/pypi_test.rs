use std::process::Command;
use std::path::PathBuf;
use std::fs;

fn get_manifest_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
}

#[test]
fn test_pypi_setup_py_complete() {
    println!("=== PyPI: setup.py has required fields for publishing ===");
    
    let manifest_dir = get_manifest_dir();
    let setup_py = manifest_dir.join("bindings/python/setup.py");
    
    assert!(setup_py.exists(), "bindings/python/setup.py should exist");
    
    let content = fs::read_to_string(&setup_py)
        .expect("Failed to read setup.py");
    
    // Required fields for PyPI
    assert!(content.contains("name="), "setup.py should have 'name' field");
    assert!(content.contains("version="), "setup.py should have 'version' field");
    assert!(content.contains("description="), "setup.py should have 'description' field");
    assert!(content.contains("author="), "setup.py should have 'author' field");
    assert!(content.contains("license="), "setup.py should have 'license' field");
    assert!(content.contains("classifiers="), "setup.py should have 'classifiers' field");
    assert!(content.contains("python_requires="), "setup.py should have 'python_requires' field");
    assert!(content.contains("url=") || content.contains("project_urls="), "setup.py should have URL fields");
    assert!(content.contains("long_description="), "setup.py should have 'long_description' field");
    assert!(content.contains("long_description_content_type="), "setup.py should have 'long_description_content_type' field");
    
    println!("✓ setup.py has all required fields for PyPI publishing");
}

#[test]
fn test_pypi_readme_exists() {
    println!("=== PyPI: README.md exists in Python bindings ===");
    
    let manifest_dir = get_manifest_dir();
    let readme = manifest_dir.join("bindings/python/README.md");
    
    assert!(readme.exists(), "bindings/python/README.md should exist for PyPI");
    
    let content = fs::read_to_string(&readme)
        .expect("Failed to read README.md");
    
    assert!(content.contains("TOONify"), "README should mention TOONify");
    assert!(content.contains("install"), "README should have install instructions");
    assert!(content.contains("import"), "README should have import examples");
    assert!(content.contains("json_to_toon") || content.contains("toon_to_json"), "README should mention conversion functions");
    
    println!("✓ README.md exists and contains essential information");
}

#[test]
fn test_pypi_manifest_in_exists() {
    println!("=== PyPI: MANIFEST.in includes native library ===");
    
    let manifest_dir = get_manifest_dir();
    let manifest_in = manifest_dir.join("bindings/python/MANIFEST.in");
    
    assert!(manifest_in.exists(), "bindings/python/MANIFEST.in should exist");
    
    let content = fs::read_to_string(&manifest_in)
        .expect("Failed to read MANIFEST.in");
    
    // Should include native libraries for all platforms
    assert!(content.contains("*.dylib") || content.contains("libtoonify"), "MANIFEST.in should include macOS library");
    assert!(content.contains("*.so") || content.contains("libtoonify"), "MANIFEST.in should include Linux library");
    assert!(content.contains("*.dll") || content.contains("toonify.dll"), "MANIFEST.in should include Windows library");
    
    println!("✓ MANIFEST.in includes native library for all platforms");
}

#[test]
fn test_pypi_python_files_exist() {
    println!("=== PyPI: All Python package files exist ===");
    
    let manifest_dir = get_manifest_dir();
    let python_dir = manifest_dir.join("bindings/python");
    
    assert!(python_dir.exists(), "bindings/python/ directory should exist");
    
    let setup_py = python_dir.join("setup.py");
    assert!(setup_py.exists(), "setup.py should exist");
    
    let toonify_py = python_dir.join("toonify.py");
    assert!(toonify_py.exists(), "toonify.py should exist (generated by UniFFI)");
    
    let lib_file = python_dir.join("libtoonify.dylib");
    assert!(lib_file.exists(), "libtoonify.dylib should exist (native library)");
    
    // Check file sizes
    let py_metadata = fs::metadata(&toonify_py).expect("Failed to get toonify.py metadata");
    assert!(py_metadata.len() > 1000, "toonify.py should be at least 1KB");
    
    let lib_metadata = fs::metadata(&lib_file).expect("Failed to get library metadata");
    assert!(lib_metadata.len() > 100_000, "Native library should be at least 100KB");
    
    println!("✓ All package files exist and have reasonable sizes");
}

#[test]
fn test_pypi_build_sdist() {
    println!("=== PyPI: Can build source distribution (sdist) ===");
    
    let manifest_dir = get_manifest_dir();
    let python_dir = manifest_dir.join("bindings/python");
    
    // Clean previous builds
    let dist_dir = python_dir.join("dist");
    let _ = fs::remove_dir_all(&dist_dir);
    
    let build_dir = python_dir.join("build");
    let _ = fs::remove_dir_all(&build_dir);
    
    // Build source distribution
    let output = Command::new("python3")
        .args(&["setup.py", "sdist"])
        .current_dir(&python_dir)
        .output()
        .expect("Failed to run python3 setup.py sdist");
    
    println!("sdist exit status: {}", output.status);
    if !output.stdout.is_empty() {
        println!("sdist stdout:\n{}", String::from_utf8_lossy(&output.stdout));
    }
    if !output.stderr.is_empty() {
        println!("sdist stderr:\n{}", String::from_utf8_lossy(&output.stderr));
    }
    
    assert!(output.status.success(), "python3 setup.py sdist should succeed");
    
    // Verify dist directory was created
    assert!(dist_dir.exists(), "dist/ directory should be created");
    
    // Find the .tar.gz file
    let dist_files: Vec<_> = fs::read_dir(&dist_dir)
        .expect("Failed to read dist directory")
        .filter_map(|e| e.ok())
        .filter(|e| {
            e.path()
                .extension()
                .and_then(|s| s.to_str())
                .map(|s| s == "gz")
                .unwrap_or(false)
        })
        .collect();
    
    assert!(!dist_files.is_empty(), "Should create at least one .tar.gz file");
    
    let tarball = &dist_files[0].path();
    let tarball_size = fs::metadata(tarball)
        .expect("Failed to get tarball metadata")
        .len();
    
    assert!(tarball_size > 100_000, "Source distribution should be at least 100KB");
    
    println!("✓ Source distribution built successfully: {} ({} bytes)", 
             tarball.display(), tarball_size);
}

#[test]
fn test_pypi_package_installable() {
    println!("=== PyPI: Package can be installed with pip ===");
    
    let manifest_dir = get_manifest_dir();
    let python_dir = manifest_dir.join("bindings/python");
    
    // Create a temporary virtual environment
    let test_venv = manifest_dir.join("test_venv_pypi");
    let _ = fs::remove_dir_all(&test_venv); // Clean up if exists
    
    // Create virtual environment
    let venv_output = Command::new("python3")
        .args(&["-m", "venv", test_venv.to_str().unwrap()])
        .output()
        .expect("Failed to create virtual environment");
    
    assert!(venv_output.status.success(), "Creating venv should succeed");
    
    // Determine pip path
    let pip_path = if cfg!(target_os = "windows") {
        test_venv.join("Scripts").join("pip")
    } else {
        test_venv.join("bin").join("pip")
    };
    
    // Install the package in editable mode
    let install_output = Command::new(&pip_path)
        .args(&["install", "-e", python_dir.to_str().unwrap()])
        .output()
        .expect("Failed to run pip install");
    
    println!("pip install exit status: {}", install_output.status);
    if !install_output.stdout.is_empty() {
        println!("pip install stdout:\n{}", String::from_utf8_lossy(&install_output.stdout));
    }
    if !install_output.stderr.is_empty() {
        println!("pip install stderr:\n{}", String::from_utf8_lossy(&install_output.stderr));
    }
    
    assert!(install_output.status.success(), "pip install should succeed");
    
    // Determine python path
    let python_path = if cfg!(target_os = "windows") {
        test_venv.join("Scripts").join("python")
    } else {
        test_venv.join("bin").join("python")
    };
    
    // Test import
    let test_import = Command::new(&python_path)
        .args(&["-c", "import toonify; print('Import successful')"])
        .output()
        .expect("Failed to run python -c");
    
    println!("Import test exit status: {}", test_import.status);
    if !test_import.stdout.is_empty() {
        println!("Import test stdout:\n{}", String::from_utf8_lossy(&test_import.stdout));
    }
    if !test_import.stderr.is_empty() {
        println!("Import test stderr:\n{}", String::from_utf8_lossy(&test_import.stderr));
    }
    
    assert!(test_import.status.success(), "Importing toonify should succeed");
    assert!(String::from_utf8_lossy(&test_import.stdout).contains("Import successful"), 
            "Import should print success message");
    
    // Test actual functionality
    let test_functionality = Command::new(&python_path)
        .args(&["-c", r#"
import toonify
import json
data = json.dumps({"users": [{"id": 1, "name": "Test"}]})
toon = toonify.json_to_toon(data)
print("Conversion successful:", "users" in toon)
"#])
        .output()
        .expect("Failed to run functionality test");
    
    println!("Functionality test exit status: {}", test_functionality.status);
    if !test_functionality.stdout.is_empty() {
        println!("Functionality test stdout:\n{}", String::from_utf8_lossy(&test_functionality.stdout));
    }
    if !test_functionality.stderr.is_empty() {
        println!("Functionality test stderr:\n{}", String::from_utf8_lossy(&test_functionality.stderr));
    }
    
    assert!(test_functionality.status.success(), "Functionality test should succeed");
    assert!(String::from_utf8_lossy(&test_functionality.stdout).contains("Conversion successful: True"), 
            "Conversion should work correctly");
    
    // Clean up
    let _ = fs::remove_dir_all(&test_venv);
    
    println!("✓ Package installed and works correctly");
}

#[test]
fn test_pypi_check_command() {
    println!("=== PyPI: Package passes twine check ===");
    
    let manifest_dir = get_manifest_dir();
    let python_dir = manifest_dir.join("bindings/python");
    
    // First, ensure we have a dist to check (build if needed)
    let dist_dir = python_dir.join("dist");
    if !dist_dir.exists() || fs::read_dir(&dist_dir).unwrap().count() == 0 {
        let _ = Command::new("python3")
            .args(&["setup.py", "sdist"])
            .current_dir(&python_dir)
            .output();
    }
    
    // Check if twine is installed, skip if not
    let twine_check = Command::new("python3")
        .args(&["-m", "twine", "--version"])
        .output();
    
    if twine_check.is_err() || !twine_check.unwrap().status.success() {
        println!("⚠ Twine not installed, skipping check (install with: pip install twine)");
        return;
    }
    
    // Run twine check
    let check_output = Command::new("python3")
        .args(&["-m", "twine", "check", "dist/*"])
        .current_dir(&python_dir)
        .output()
        .expect("Failed to run twine check");
    
    println!("twine check exit status: {}", check_output.status);
    if !check_output.stdout.is_empty() {
        println!("twine check stdout:\n{}", String::from_utf8_lossy(&check_output.stdout));
    }
    if !check_output.stderr.is_empty() {
        println!("twine check stderr:\n{}", String::from_utf8_lossy(&check_output.stderr));
    }
    
    let output_str = String::from_utf8_lossy(&check_output.stdout);
    assert!(check_output.status.success(), "twine check should succeed");
    assert!(output_str.contains("PASSED"), "Package should pass twine validation");
    
    println!("✓ Package passes twine check (ready for PyPI upload)");
}

